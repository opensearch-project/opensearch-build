/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */

lib = library(identifier: 'jenkins@6.1.1', retriever: modernSCM([
    $class: 'GitSCMSource',
    remote: 'https://github.com/opensearch-project/opensearch-build-libraries.git',
]))

pipeline {
    options {
        timeout(time: 4, unit: 'HOURS')
    }
    agent none
    environment {
        AGENT_LINUX_X64 = 'Jenkins-Agent-AL2023-X64-C54xlarge-Docker-Host'
        AGENT_LINUX_ARM64 = 'Jenkins-Agent-AL2023-Arm64-C6g4xlarge-Docker-Host'
        AGENT_WINDOWS_X64 = 'Jenkins-Agent-Windows2019-X64-C54xlarge-Docker-Host'
        IMAGE_LINUX_RPM = 'opensearchstaging/ci-runner:ci-runner-rockylinux8-opensearch-build-v4' // required for rpm to create digest sha256 correctly with rpm 4.12+, still define here for 1.x version as 2.x+ moved to rockylinux8 already
        IMAGE_LINUX_DEB = 'opensearchstaging/ci-runner:ci-runner-ubuntu2004-opensearch-build-v2' // required for deb to create pkg using debmake/debuild/debhelper
        IMAGE_WINDOWS_ZIP = 'opensearchstaging/ci-runner:ci-runner-windows2019-servercore-opensearch-build-v1' // required for windows to build zip distribution
    }
    parameters {
        string(
            name: 'COMPONENT_NAME',
            description: 'If this field contains one or more component names (e.g. OpenSearch common-utils ...), will build with "--component <COMPONENT_NAME> ...", else build everything in the INPUT_MANIFEST.',
            trim: true
        )
        string(
            name: 'INPUT_MANIFEST',
            description: 'Input manifest under the manifests folder, e.g. 2.0.0/opensearch-2.0.0.yml.',
            trim: true
        )
        string(
            name: 'TEST_MANIFEST',
            description: 'Test manifest under the manifests folder, e.g. 2.0.0/opensearch-2.0.0-test.yml.',
            trim: true
        )
        string(
            name: 'INTEG_TEST_JOB_NAME',
            description: 'Name of integration test job that will be triggered, e.g. Playground/integ-test. A non-null empty value here will skip integration tests.',
            defaultValue: 'integ-test',
            trim: true
        )
        string(
            name: 'BWC_TEST_JOB_NAME',
            description: 'Name of backwards compatibility test job that will be triggered, e.g. Playground/bwc-test.  A non-null empty value here will skip BWC tests.',
            defaultValue: 'bwc-test',
            trim: true
        )
        string( // Note: need to update 'verify-parameters' entries if you add new platform(s)
            name: 'BUILD_PLATFORM',
            description: "Build selected platform related artifacts, choices include 'linux', 'macos', 'windows'. Can combine multiple platforms with space in between (maven snapshot is only on linux)",
            defaultValue: 'linux macos windows',
            trim: true
        )
        choice(
            name: 'BUILD_DOCKER',
            description: 'Build docker image or not with options.',
            choices: ['build_docker', 'build_docker_with_build_number_tag', 'do_not_build_docker'],
        )
        booleanParam(
            name: 'UPDATE_LATEST_URL',
            description: 'Update latest url so /latest/ is pointed to this build',
            defaultValue: true
        )
        booleanParam(
            name: 'PUBLISH_NOTIFICATION',
            description: 'Publish the status of this build job or not.',
            defaultValue: true
        )
        booleanParam(
            name: 'CREATE_GITHUB_ISSUE',
            description: 'To create a github issue for failing component or not.',
            defaultValue: true
        )
        booleanParam(
            name: 'CONTINUE_ON_ERROR',
            description: 'Continue building the distribution even if a one or more component fails',
            defaultValue: true
        )
        booleanParam(
            name: 'INCREMENTAL',
            description: 'Whether to trigger incremental build. Defaults to false.',
            defaultValue: true
        )
        string(
            name: 'PREVIOUS_BUILD_ID',
            description: 'The build ID used to download previous build artifacts. Defaults to latest.',
            defaultValue: 'latest',
            trim: true
        )
    }
    stages {
        stage('verify-parameters') {
            agent {
                docker {
                    label AGENT_LINUX_X64
                    image 'docker/library/alpine:3'
                    registryUrl 'https://public.ecr.aws/'
                    alwaysPull true
                }
            }
            steps {
                script {
                    echo('Detect Docker Images and Related Parameters')
                    dockerAgent = detectDockerAgent()
                    env.javaVersionNumber = dockerAgent.javaVersion.replaceAll('[^0-9]', '') // Only get number
                    currentBuild.description = INPUT_MANIFEST

                    echo('Verify Build Platforms')
                    def build_platform_array = params.BUILD_PLATFORM.tokenize(' ')
                    echo("User Entry Platforms: '${params.BUILD_PLATFORM}', ${build_platform_array}")
                    def all_platforms = 'linux macos windows'
                    echo("All Supported Platforms: '${all_platforms}'")

                    if (params.BUILD_PLATFORM == null || params.BUILD_PLATFORM == '') {
                        currentBuild.result = 'ABORTED'
                        error("Missing parameter: BUILD_PLATFORM (possible entries: ${all_platforms}).")
                    }

                    for (String plat : build_platform_array) {
                        if (! all_platforms.contains(plat)) {
                            currentBuild.result = 'ABORTED'
                            error("Missing parameter: BUILD_PLATFORM (possible entries: ${all_platforms}).")
                        }
                    }
                }
            }
        }
        stage('build') {
            parallel {
                stage('Trigger-min-snapshot-build') {
                    agent {
                        docker {
                            label 'Jenkins-Agent-AL2023-X64-C54xlarge-Docker-Host'
                            image 'docker/library/alpine:3'
                            registryUrl 'https://public.ecr.aws/'
                            alwaysPull true
                        }
                    }
                    steps {
                        script {
                            def snapshotBuild =
                                build job: 'publish-opensearch-min-snapshots',
                                propagate: false,
                                wait: false,
                                parameters: [
                                    string(name: 'INPUT_MANIFEST', value: "${INPUT_MANIFEST}"),
                                ]
                        }
                    }
                }
                stage('build-and-test-linux-x64-tar') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('linux')
                        }
                    }
                    agent {
                        docker {
                            label AGENT_LINUX_X64
                            image dockerAgent.image
                            args dockerAgent.args
                            registryUrl 'https://public.ecr.aws/'
                            alwaysPull true
                        }
                    }
                    steps {
                        script {
                            def buildManifestObj = buildAssembleUpload(
                                componentName: "${COMPONENT_NAME}",
                                inputManifest: "manifests/${INPUT_MANIFEST}",
                                platform: 'linux',
                                architecture: 'x64',
                                distribution: 'tar',
                                continueOnError: params.CONTINUE_ON_ERROR,
                                incremental: params.INCREMENTAL,
                                previousBuildId: params.PREVIOUS_BUILD_ID
                            )
                            String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                            String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                            env.ARTIFACT_URL_LINUX_X64_TAR = artifactUrl
                            env.INDEX_FILE_PATH_X64_TAR = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                            echo "buildManifestUrl (linux, x64, tar): ${buildManifestUrl}"
                            echo "artifactUrl (linux, x64, tar): ${artifactUrl}"

                            parallel([
                                'integ-test': {
                                    triggerIntegrationTests(buildManifestUrl)
                                },
                                'bwc-test': {
                                    Boolean skipBwcTests = (BWC_TEST_JOB_NAME == '' || TEST_MANIFEST == '' || buildManifestUrl == '')
                                    echo "${skipBwcTests ? 'Skipping BWC tests as one of the values has empty string: BWC_TEST_JOB_NAME, TEST_MANIFEST, buildManifestUrl' : 'Running BWC tests'}"
                                    if (!skipBwcTests) {
                                        def bwcTestResults =
                                            build job: BWC_TEST_JOB_NAME,
                                            propagate: false,
                                            wait: false,
                                            parameters: [
                                                string(name: 'TEST_MANIFEST', value: TEST_MANIFEST),
                                                string(name: 'BUILD_MANIFEST_URL', value: buildManifestUrl),
                                                string(name: 'AGENT_LABEL', value: AGENT_LINUX_X64)
                                            ]
                                    }
                                }
                                ])
                        }
                    }
                    post {
                        success {
                            script {
                                if (params.UPDATE_LATEST_URL) {
                                    uploadIndexFile(
                                        indexFilePath: env.INDEX_FILE_PATH_X64_TAR
                                    )
                                }
                            }
                        }
                        unstable {
                            script {
                                if (params.UPDATE_LATEST_URL) {
                                    uploadIndexFile(
                                        indexFilePath: env.INDEX_FILE_PATH_X64_TAR
                                    )
                                }
                            }
                        }
                        always {
                            script {
                                lib.jenkins.Messages.new(this).add(
                                    "${STAGE_NAME}",
                                    lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                )
                                if (params.CONTINUE_ON_ERROR) {
                                    markStageUnstableIfPluginsFailedToBuild()
                                }
                                postCleanup()
                            }
                        }
                    }
                }
                stage('build-and-test-linux-x64-rpm') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('linux')
                        }
                    }
                    agent { label AGENT_LINUX_X64 }
                    stages {
                        stage('build-archive-linux-x64-rpm') {
                            agent {
                                docker {
                                    label AGENT_LINUX_X64
                                    image dockerAgent.image
                                    args dockerAgent.args
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    buildArchive(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'x64',
                                        distribution: 'rpm',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        incremental: params.INCREMENTAL,
                                        previousBuildId: params.PREVIOUS_BUILD_ID,
                                        stashName: "build-archive-linux-x64-rpm-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                }
                            }
                            post {
                                always {
                                    script {
                                        if (params.CONTINUE_ON_ERROR) {
                                            markStageUnstableIfPluginsFailedToBuild()
                                        }
                                        postCleanup()
                                    }
                                }
                            }
                        }
                        stage('assemble-archive-and-test-linux-x64-rpm') {
                            agent {
                                docker {
                                    label AGENT_LINUX_X64
                                    image IMAGE_LINUX_RPM
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    def buildManifestObj = archiveAssembleUpload(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'x64',
                                        distribution: 'rpm',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        stashName: "build-archive-linux-x64-rpm-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                    String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                                    String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                                    env.ARTIFACT_URL_LINUX_X64_RPM = artifactUrl
                                    env.INDEX_FILE_PATH_X64_RPM = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                                    echo "buildManifestUrl (linux, x64, rpm): ${buildManifestUrl}"
                                    echo "artifactUrl (linux, x64, rpm): ${artifactUrl}"

                                    String bundleManifestUrl = buildManifestObj.getBundleManifestUrl(JOB_NAME, BUILD_NUMBER)
                                    parallel([
                                        'integ-test': {
                                            triggerIntegrationTests(buildManifestUrl)
                                        },
                                        'rpm-validation': {
                                            triggerRpmValidation(bundleManifestUrl)
                                        }
                                    ])
                                }
                            }
                            post {
                                success {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_X64_RPM
                                            )
                                        }
                                    }
                                }
                                unstable {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_X64_RPM
                                            )
                                        }
                                    }
                                }
                                always {
                                    script {
                                        lib.jenkins.Messages.new(this).add(
                                            "${STAGE_NAME}",
                                            lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                        )
                                        postCleanup()
                                    }
                                }
                            }
                        }
                    }
                }
                stage('build-and-test-linux-x64-deb') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('linux')
                        }
                    }
                    agent { label AGENT_LINUX_X64 }
                    stages {
                        stage('build-archive-linux-x64-deb') {
                            agent {
                                docker {
                                    label AGENT_LINUX_X64
                                    image dockerAgent.image
                                    args dockerAgent.args
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    buildArchive(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'x64',
                                        distribution: 'deb',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        incremental: params.INCREMENTAL,
                                        previousBuildId: params.PREVIOUS_BUILD_ID,
                                        stashName: "build-archive-linux-x64-deb-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                }
                            }
                            post {
                                always {
                                    script {
                                        if (params.CONTINUE_ON_ERROR) {
                                            markStageUnstableIfPluginsFailedToBuild()
                                        }
                                        postCleanup()
                                    }
                                }
                            }
                        }
                        stage('assemble-archive-and-test-linux-x64-deb') {
                            agent {
                                docker {
                                    label AGENT_LINUX_X64
                                    image IMAGE_LINUX_DEB
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    def buildManifestObj = archiveAssembleUpload(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'x64',
                                        distribution: 'deb',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        stashName: "build-archive-linux-x64-deb-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                    String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                                    String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                                    env.ARTIFACT_URL_LINUX_X64_DEB = artifactUrl
                                    env.INDEX_FILE_PATH_X64_DEB = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                                    echo "buildManifestUrl (linux, x64, deb): ${buildManifestUrl}"
                                    echo "artifactUrl (linux, x64, deb): ${artifactUrl}"

                                    String bundleManifestUrl = buildManifestObj.getBundleManifestUrl(JOB_NAME, BUILD_NUMBER)
                                    triggerIntegrationTests(buildManifestUrl)
                                }
                            }
                            post {
                                success {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_X64_DEB
                                            )
                                        }
                                    }
                                }
                                unstable {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_X64_DEB
                                            )
                                        }
                                    }
                                }
                                always {
                                    script {
                                        lib.jenkins.Messages.new(this).add(
                                            "${STAGE_NAME}",
                                            lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                        )

                                        postCleanup()
                                    }
                                }
                            }
                        }
                    }
                }
                stage('build-and-test-linux-arm64-tar') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('linux')
                        }
                    }
                    agent {
                        docker {
                            label AGENT_LINUX_ARM64
                            image dockerAgent.image
                            args dockerAgent.args
                            registryUrl 'https://public.ecr.aws/'
                            alwaysPull true
                        }
                    }
                    steps {
                        script {
                            def buildManifestObj = buildAssembleUpload(
                                componentName: "${COMPONENT_NAME}",
                                inputManifest: "manifests/${INPUT_MANIFEST}",
                                platform: 'linux',
                                architecture: 'arm64',
                                distribution: 'tar',
                                continueOnError: params.CONTINUE_ON_ERROR,
                                incremental: params.INCREMENTAL,
                                previousBuildId: params.PREVIOUS_BUILD_ID
                            )
                            String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                            String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                            env.ARTIFACT_URL_LINUX_ARM64_TAR = artifactUrl
                            env.INDEX_FILE_PATH_ARM64_TAR = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                            echo "buildManifestUrl (linux, arm64, tar): ${buildManifestUrl}"
                            echo "artifactUrl (linux, arm64, tar): ${artifactUrl}"
                            triggerIntegrationTests(buildManifestUrl)
                        }
                    }
                    post {
                        success {
                            script {
                                if (params.UPDATE_LATEST_URL) {
                                    uploadIndexFile(
                                        indexFilePath: env.INDEX_FILE_PATH_ARM64_TAR
                                    )
                                }
                            }
                        }
                        unstable {
                            script {
                                if (params.UPDATE_LATEST_URL) {
                                    uploadIndexFile(
                                        indexFilePath: env.INDEX_FILE_PATH_ARM64_TAR
                                    )
                                }
                            }
                        }
                        always {
                            script {
                                lib.jenkins.Messages.new(this).add(
                                    "${STAGE_NAME}",
                                    lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                )
                                if (params.CONTINUE_ON_ERROR) {
                                    markStageUnstableIfPluginsFailedToBuild()
                                }
                                postCleanup()
                            }
                        }
                    }
                }
                stage('build-and-test-linux-arm64-rpm') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('linux')
                        }
                    }
                    agent { label AGENT_LINUX_X64 }
                    stages {
                        stage('build-archive-linux-arm64-rpm') {
                            agent {
                                docker {
                                    label AGENT_LINUX_ARM64
                                    image dockerAgent.image
                                    args dockerAgent.args
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    buildArchive(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'arm64',
                                        distribution: 'rpm',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        incremental: params.INCREMENTAL,
                                        previousBuildId: params.PREVIOUS_BUILD_ID,
                                        stashName: "build-archive-linux-arm64-rpm-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                }
                            }
                            post {
                                always {
                                    script {
                                        if (params.CONTINUE_ON_ERROR) {
                                            markStageUnstableIfPluginsFailedToBuild()
                                        }
                                        postCleanup()
                                    }
                                }
                            }
                        }
                        stage('assemble-archive-and-test-linux-arm64-rpm') {
                            agent {
                                docker {
                                    label AGENT_LINUX_ARM64
                                    image IMAGE_LINUX_RPM
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    def buildManifestObj = archiveAssembleUpload(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'arm64',
                                        distribution: 'rpm',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        stashName: "build-archive-linux-arm64-rpm-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                    String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                                    String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                                    env.ARTIFACT_URL_LINUX_ARM64_RPM = artifactUrl
                                    env.INDEX_FILE_PATH_ARM64_RPM = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                                    echo "buildManifestUrl (linux, arm64, rpm): ${buildManifestUrl}"
                                    echo "artifactUrl (linux, arm64, rpm): ${artifactUrl}"

                                    String bundleManifestUrl = buildManifestObj.getBundleManifestUrl(JOB_NAME, BUILD_NUMBER)
                                    parallel([
                                        'integ-test': {
                                            triggerIntegrationTests(buildManifestUrl)
                                        },
                                        'rpm-validation': {
                                            triggerRpmValidation(bundleManifestUrl)
                                        }
                                    ])
                                }
                            }
                            post {
                                success {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_ARM64_RPM
                                            )
                                        }
                                    }
                                }
                                unstable {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_ARM64_RPM
                                            )
                                        }
                                    }
                                }
                                always {
                                    script {
                                        lib.jenkins.Messages.new(this).add(
                                            "${STAGE_NAME}",
                                            lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                        )
                                        postCleanup()
                                    }
                                }
                            }
                        }
                    }
                }
                stage('build-and-test-linux-arm64-deb') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('linux')
                        }
                    }
                    agent { label AGENT_LINUX_ARM64 }
                    stages {
                        stage('build-archive-linux-arm64-deb') {
                            agent {
                                docker {
                                    label AGENT_LINUX_ARM64
                                    image dockerAgent.image
                                    args dockerAgent.args
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    buildArchive(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'arm64',
                                        distribution: 'deb',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        incremental: params.INCREMENTAL,
                                        previousBuildId: params.PREVIOUS_BUILD_ID,
                                        stashName: "build-archive-linux-arm64-deb-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                }
                            }
                            post {
                                always {
                                    script {
                                        if (params.CONTINUE_ON_ERROR) {
                                            markStageUnstableIfPluginsFailedToBuild()
                                        }
                                        postCleanup()
                                    }
                                }
                            }
                        }
                        stage('assemble-archive-and-test-linux-arm64-deb') {
                            agent {
                                docker {
                                    label AGENT_LINUX_ARM64
                                    image IMAGE_LINUX_DEB
                                    registryUrl 'https://public.ecr.aws/'
                                    alwaysPull true
                                }
                            }
                            steps {
                                script {
                                    def buildManifestObj = archiveAssembleUpload(
                                        componentName: "${COMPONENT_NAME}",
                                        inputManifest: "manifests/${INPUT_MANIFEST}",
                                        platform: 'linux',
                                        architecture: 'arm64',
                                        distribution: 'deb',
                                        continueOnError: params.CONTINUE_ON_ERROR,
                                        stashName: "build-archive-linux-arm64-deb-${JOB_NAME}-${BUILD_NUMBER}"
                                    )
                                    String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                                    String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                                    env.ARTIFACT_URL_LINUX_ARM64_DEB = artifactUrl
                                    env.INDEX_FILE_PATH_ARM64_DEB = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                                    echo "buildManifestUrl (linux, arm64, deb): ${buildManifestUrl}"
                                    echo "artifactUrl (linux, arm64, deb): ${artifactUrl}"

                                    String bundleManifestUrl = buildManifestObj.getBundleManifestUrl(JOB_NAME, BUILD_NUMBER)
                                    triggerIntegrationTests(buildManifestUrl)
                                }
                            }
                            post {
                                success {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_ARM64_DEB
                                            )
                                        }
                                    }
                                }
                                unstable {
                                    script {
                                        if (params.UPDATE_LATEST_URL) {
                                            uploadIndexFile(
                                                indexFilePath: env.INDEX_FILE_PATH_ARM64_DEB
                                            )
                                        }
                                    }
                                }
                                always {
                                    script {
                                        lib.jenkins.Messages.new(this).add(
                                            "${STAGE_NAME}",
                                            lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                        )
                                        postCleanup()
                                    }
                                }
                            }
                        }
                    }
                }
                stage('build-and-test-windows-x64-zip') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('windows')
                        }
                    }
                    agent {
                        docker {
                            label AGENT_WINDOWS_X64
                            image IMAGE_WINDOWS_ZIP
                            registryUrl 'https://public.ecr.aws/'
                            alwaysPull true
                        }
                    }
                    steps {
                        script {
                            echo("Switching to Java ${env.javaVersionNumber} on Windows Docker Container")
                            sh("scoop reset `scoop list jdk | cut -d ' ' -f1 | grep ${env.javaVersionNumber} | head -1`")
                            def buildManifestObj = buildAssembleUpload(
                                componentName: "${COMPONENT_NAME}",
                                inputManifest: "manifests/${INPUT_MANIFEST}",
                                platform: 'windows',
                                architecture: 'x64',
                                distribution: 'zip',
                                continueOnError: params.CONTINUE_ON_ERROR,
                                incremental: params.INCREMENTAL,
                                previousBuildId: params.PREVIOUS_BUILD_ID
                            )
                            String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                            String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                            env.ARTIFACT_URL_LINUX_WINDOWS_X64_ZIP = artifactUrl
                            env.INDEX_FILE_PATH_X64_ZIP = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                            echo "buildManifestUrl (windows, x64, zip): ${buildManifestUrl}"
                            echo "artifactUrl (windows, x64, zip): ${artifactUrl}"
                            triggerIntegrationTests(buildManifestUrl)
                        }
                    }
                    post {
                        success {
                            script {
                                if (params.UPDATE_LATEST_URL) {
                                    uploadIndexFile(
                                        indexFilePath: env.INDEX_FILE_PATH_X64_ZIP
                                    )
                                }
                            }
                        }
                        unstable {
                            script {
                                if (params.UPDATE_LATEST_URL) {
                                    uploadIndexFile(
                                        indexFilePath: env.INDEX_FILE_PATH_X64_ZIP
                                    )
                                }
                            }
                        }
                        always {
                            script {
                                lib.jenkins.Messages.new(this).add(
                                    "${STAGE_NAME}",
                                    lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                )
                                if (params.CONTINUE_ON_ERROR) {
                                    markStageUnstableIfPluginsFailedToBuild()
                                }
                                postCleanup()
                            }
                        }
                    }
                }
            }
        }
        stage('docker build') {
            when {
                beforeAgent true
                allOf {
                    expression {
                        params.BUILD_DOCKER != 'do_not_build_docker'
                    }
                    expression {
                        params.BUILD_PLATFORM.contains('linux')
                    }
                }
            }
            agent {
                docker {
                    label AGENT_LINUX_X64
                    image dockerAgent.image
                    args dockerAgent.args
                    registryUrl 'https://public.ecr.aws/'
                    alwaysPull true
                }
            }
            steps {
                script {
                    echo "env.ARTIFACT_URL_LINUX_X64_TAR: ${env.ARTIFACT_URL_X64_TAR}"
                    echo "env.ARTIFACT_URL_LINUX_ARM64_TAR: ${env.ARTIFACT_URL_ARM64_TAR}"

                    buildDockerImage(
                        inputManifest: "manifests/${INPUT_MANIFEST}",
                        buildNumber: "${BUILD_NUMBER}",
                        buildOption: "${BUILD_DOCKER}",
                        artifactUrlX64: env.ARTIFACT_URL_LINUX_X64_TAR,
                        artifactUrlArm64: env.ARTIFACT_URL_LINUX_ARM64_TAR
                    )
                }
            }
        }
    }
    post {
        always {
            node(AGENT_LINUX_X64) {
                checkout scm
                script {
                    closeBuildSuccessGithubIssue(
                        message: buildMessage(search: 'Successfully built'),
                        search: 'Successfully built',
                        inputManifestPath: "manifests/$INPUT_MANIFEST"
                    )
                    if (params.CREATE_GITHUB_ISSUE) {
                        createBuildFailureGithubIssue(
                            message: buildMessage(search: 'Error building'),
                            inputManifestPath: "manifests/$INPUT_MANIFEST"
                        )
                    }
                    postCleanup()
                }
            }
        }
        success {
            node(AGENT_LINUX_X64) {
                script {
                    List<String> stages = []
                    if (params.BUILD_PLATFORM.contains('linux')) {
                        stages = [
                            'build-and-test-linux-x64-tar',
                            'assemble-archive-and-test-linux-x64-rpm',
                            'assemble-archive-and-test-linux-x64-deb',
                            'build-and-test-linux-arm64-tar',
                            'assemble-archive-and-test-linux-arm64-rpm',
                            'assemble-archive-and-test-linux-arm64-deb',
                        ]
                    }
                    if (params.BUILD_PLATFORM.contains('windows')) {
                        stages.add('build-and-test-windows-x64-zip')
                    }

                    if (params.PUBLISH_NOTIFICATION) {
                        def stashed = lib.jenkins.Messages.new(this).get(stages)

                        publishNotification(
                            icon: ':white_check_mark:',
                            message: 'Successful Build',
                            extra: stashed,
                            credentialsId: 'jenkins-build-notice-webhook',
                            manifest: "${INPUT_MANIFEST}"
                        )
                    }
                    postCleanup()
                }
            }
        }
        failure {
            node(AGENT_LINUX_X64) {
                checkout scm
                script {
                    if (params.PUBLISH_NOTIFICATION) {
                        publishNotification(
                            icon: ':warning:',
                            message: buildMessage(search: 'Error building'),
                            credentialsId: 'jenkins-build-notice-webhook',
                            manifest: "${INPUT_MANIFEST}"
                        )
                    }
                    postCleanup()
                }
            }
        }
    }
}

def markStageUnstableIfPluginsFailedToBuild() {
    def stageLogs = getLogsForStage(stageName: "${STAGE_NAME}")
    if (stageLogs.any { e -> e.contains('Failed plugins are') }) {
        unstable('Some plugins failed to build. See the ./build.sh step for logs and more details')
}
    }

def triggerIntegrationTests(String buildManifestUrl) {
    Boolean skipIntegTests = (INTEG_TEST_JOB_NAME == '' || TEST_MANIFEST == '' || buildManifestUrl == '')
    echo "${skipIntegTests ? 'Skipping integration tests as one of the values has empty string: INTEG_TEST_JOB_NAME, TEST_MANIFEST, buildManifestUrl' : 'Running integration tests'}"
    if (!skipIntegTests) {
        def integTestResults =
                build job: INTEG_TEST_JOB_NAME,
                propagate: false,
                wait: false,
                parameters: [
                    string(name: 'TEST_MANIFEST', value: TEST_MANIFEST),
                    string(name: 'BUILD_MANIFEST_URL', value: buildManifestUrl),
                    booleanParam(name: 'UPDATE_GITHUB_ISSUES', value: true)
                ]
    }
}

def triggerRpmValidation(String bundleManifestUrl) {
    echo "Triggering RPM validation for ${bundleManifestUrl}"
    def rpmValidationResults =
            build job: 'rpm-validation',
            propagate: false,
            wait: false,
            parameters: [
                string(name: 'BUNDLE_MANIFEST_URL', value: bundleManifestUrl),
                string(name: 'AGENT_LABEL', value: AGENT_LINUX_X64)
            ]
}
