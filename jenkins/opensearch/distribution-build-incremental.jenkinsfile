/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */

lib = library(identifier: 'jenkins@5.12.0', retriever: modernSCM([
    $class: 'GitSCMSource',
    remote: 'https://github.com/opensearch-project/opensearch-build-libraries.git',
]))

pipeline {
    options {
        timeout(time: 4, unit: 'HOURS')
    }
    agent none
    environment {
        AGENT_LINUX_X64 = 'Jenkins-Agent-AL2023-X64-C54xlarge-Docker-Host'
        AGENT_LINUX_ARM64 = 'Jenkins-Agent-AL2023-Arm64-C6g4xlarge-Docker-Host'
        AGENT_WINDOWS_X64 = 'Jenkins-Agent-Windows2019-X64-C54xlarge-Docker-Host'
        IMAGE_LINUX_RPM = 'opensearchstaging/ci-runner:ci-runner-rockylinux8-opensearch-build-v4' // required for rpm to create digest sha256 correctly with rpm 4.12+, still define here for 1.x version as 2.x+ moved to rockylinux8 already
        IMAGE_LINUX_DEB = 'opensearchstaging/ci-runner:ci-runner-ubuntu2004-opensearch-build-v2' // required for deb to create pkg using debmake/debuild/debhelper
        IMAGE_WINDOWS_ZIP = 'opensearchstaging/ci-runner:ci-runner-windows2019-servercore-opensearch-build-v1' // required for windows to build zip distribution
    }
    parameters {
        string(
            name: 'COMPONENT_NAME',
            description: 'If this field contains one or more component names (e.g. OpenSearch common-utils ...), will build with "--component <COMPONENT_NAME> ...", else build everything in the INPUT_MANIFEST.',
            trim: true
        )
        string(
            name: 'INPUT_MANIFEST',
            description: 'Input manifest under the manifests folder, e.g. 2.0.0/opensearch-2.0.0.yml.',
            trim: true
        )
        string(
            name: 'TEST_MANIFEST',
            description: 'Test manifest under the manifests folder, e.g. 2.0.0/opensearch-2.0.0-test.yml.',
            trim: true
        )
        string(
            name: 'INTEG_TEST_JOB_NAME',
            description: 'Name of integration test job that will be triggered, e.g. Playground/integ-test. A non-null empty value here will skip integration tests.',
            defaultValue: 'integ-test',
            trim: true
        )
        string(
            name: 'BWC_TEST_JOB_NAME',
            description: 'Name of backwards compatibility test job that will be triggered, e.g. Playground/bwc-test.  A non-null empty value here will skip BWC tests.',
            defaultValue: 'bwc-test',
            trim: true
        )
        string( // Note: need to update 'verify-parameters' entries if you add new platform(s)
            name: 'BUILD_PLATFORM',
            description: "Build selected platform related artifacts, choices include 'linux', 'macos', 'windows'. Can combine multiple platforms with space in between (maven snapshot is only on linux)",
            defaultValue: 'linux macos windows',
            trim: true
        )
        choice(
            name: 'BUILD_DOCKER',
            description: 'Build docker image or not with options.',
            choices: ['build_docker', 'build_docker_with_build_number_tag', 'do_not_build_docker'],
        )
        booleanParam(
            name: 'UPDATE_LATEST_URL',
            description: 'Update latest url so /latest/ is pointed to this build',
            defaultValue: true
        )
        booleanParam(
            name: 'PUBLISH_NOTIFICATION',
            description: 'Publish the status of this build job or not.',
            defaultValue: true
        )
        booleanParam(
            name: 'CREATE_GITHUB_ISSUE',
            description: 'To create a github issue for failing component or not.',
            defaultValue: true
        )
        booleanParam(
            name: 'CONTINUE_ON_ERROR',
            description: 'Continue building the distribution even if a one or more component fails',
            defaultValue: true
        )
    }
    stages {
        stage('verify-parameters') {
            agent {
                docker {
                    label AGENT_LINUX_X64
                    image 'docker/library/alpine:3'
                    registryUrl 'https://public.ecr.aws/'
                    alwaysPull true
                }
            }
            steps {
                script {
                    echo('Detect Docker Images and Related Parameters')
                    dockerAgent = detectDockerAgent()
                    env.javaVersionNumber = dockerAgent.javaVersion.replaceAll('[^0-9]', '') // Only get number
                    currentBuild.description = INPUT_MANIFEST

                    echo('Verify Build Platforms')
                    def build_platform_array = params.BUILD_PLATFORM.tokenize(' ')
                    echo("User Entry Platforms: '${params.BUILD_PLATFORM}', ${build_platform_array}")
                    def all_platforms = 'linux macos windows'
                    echo("All Supported Platforms: '${all_platforms}'")

                    if (params.BUILD_PLATFORM == null || params.BUILD_PLATFORM == '') {
                        currentBuild.result = 'ABORTED'
                        error("Missing parameter: BUILD_PLATFORM (possible entries: ${all_platforms}).")
                    }

                    for (String plat : build_platform_array) {
                        if (! all_platforms.contains(plat)) {
                            currentBuild.result = 'ABORTED'
                            error("Missing parameter: BUILD_PLATFORM (possible entries: ${all_platforms}).")
                        }
                    }
                }
            }
        }
        stage('build') {
            parallel {
                stage('build-and-test-linux-x64-tar') {
                    when {
                        beforeAgent true
                        expression {
                            params.BUILD_PLATFORM.contains('linux')
                        }
                    }
                    agent {
                        docker {
                            label AGENT_LINUX_X64
                            image dockerAgent.image
                            args dockerAgent.args
                            registryUrl 'https://public.ecr.aws/'
                            alwaysPull true
                        }
                    }
                    steps {
                        script {
                            def buildManifestObj = buildAssembleUpload(
                                componentName: "${COMPONENT_NAME}",
                                inputManifest: "manifests/${INPUT_MANIFEST}",
                                platform: 'linux',
                                architecture: 'x64',
                                distribution: 'tar',
                                continueOnError: params.CONTINUE_ON_ERROR
                            )
                            String buildManifestUrl = buildManifestObj.getUrl(JOB_NAME, BUILD_NUMBER)
                            String artifactUrl = buildManifestObj.getArtifactUrl(JOB_NAME, BUILD_NUMBER)
                            env.ARTIFACT_URL_LINUX_X64_TAR = artifactUrl
                            env.INDEX_FILE_PATH = buildManifestObj.getIndexFileRoot("${JOB_NAME}")

                            echo "buildManifestUrl (linux, x64, tar): ${buildManifestUrl}"
                            echo "artifactUrl (linux, x64, tar): ${artifactUrl}"
                        }
                    }
                    post {
                        always {
                            script {
                                lib.jenkins.Messages.new(this).add(
                                    "${STAGE_NAME}",
                                    lib.jenkins.Messages.new(this).get(["${STAGE_NAME}"])
                                )
                                if (params.CONTINUE_ON_ERROR) {
                                    markStageUnstableIfPluginsFailedToBuild()
                                }
                                postCleanup()
                            }
                        }
                    }
                }
            }
        }
        stage('update index file') {
            agent {
                docker {
                    label AGENT_LINUX_X64
                    image dockerAgent.image
                    args dockerAgent.args
                    registryUrl 'https://public.ecr.aws/'
                    alwaysPull true
                }
            }
            steps {
                script {
                    if (params.UPDATE_LATEST_URL) {
                        uploadIndexFile(
                            indexFilePath: env.INDEX_FILE_PATH
                        )
                    }
                }
            }
        }
    }
    post {
        always {
            node(AGENT_LINUX_X64) {
                checkout scm
                script {
                    postCleanup()
                }
            }
        }
        success {
            node(AGENT_LINUX_X64) {
                script {
                    postCleanup()
                }
            }
        }
        failure {
            node(AGENT_LINUX_X64) {
                checkout scm
                script {
                    postCleanup()
                }
            }
        }
    }
}

