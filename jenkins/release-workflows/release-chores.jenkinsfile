/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */
lib = library(identifier: 'jenkins@11.1.0', retriever: modernSCM([
    $class: 'GitSCMSource',
    remote: 'https://github.com/opensearch-project/opensearch-build-libraries.git',
]))

pipeline {
    options {
        timeout(time: 1, unit: 'HOURS')
    }
    agent {
        docker {
            label 'Jenkins-Agent-AL2023-X64-M54xlarge-Docker-Host'
            image 'opensearchstaging/ci-runner:ci-runner-al2-opensearch-build-v1'
            registryUrl 'https://public.ecr.aws/'
            alwaysPull true
        }
    }
parameters {
    activeChoice(
        name: 'RELEASE_CHORE',
        choiceType: 'PT_SINGLE_SELECT',
        description: 'Release chore to carry out',
        filterLength: 1,
        filterable: false,
        randomName: 'choice-parameter-338807851658059',
        script: groovyScript(
            fallbackScript: [classpath: [], oldScript: '', sandbox: true, script: 'return ["Unknown chore"]'],
            script: [classpath: [], oldScript: '', sandbox: true, script: '''return [ "checkReleaseOwners", "checkDocumentation", "checkCodeCoverage", "checkReleaseNotes", "checkReleaseIssues", "buildRC", "addRcDetailsComment", "checkDocumentationPullRequests", "checkIntegTestResultsOverview" ]'''])
        )
        reactiveChoice(
            name: 'ACTION',
            choiceType: 'PT_SINGLE_SELECT',
            description: 'Release chore action',
            filterLength: 1,
            filterable: false,
            randomName: 'choice-parameter-338807853238106',
            referencedParameters: 'RELEASE_CHORE',
            script: groovyScript(
                fallbackScript: [classpath: [], oldScript: '', sandbox: true, script: ' return ["Unknown action"]'],
                script: [classpath: [], oldScript: '', sandbox: true, script:
                '''if (RELEASE_CHORE == "checkReleaseOwners") {
                    return ["check", "request", "assign" ]
                    } else if (RELEASE_CHORE == "checkDocumentation") {
                    return ["check", "notify"]
                    } else if (RELEASE_CHORE == "checkCodeCoverage") {
                    return ["check", "notify"]
                    } else if (RELEASE_CHORE == "checkReleaseNotes") {
                    return ["check", "create", "compile", "notify"]
                    } else if (RELEASE_CHORE == "checkReleaseIssues") {
                    return ["check", "create"]
                    } else if (RELEASE_CHORE == "checkDocumentationPullRequests") {
                    return ["check"]
                    } else if (RELEASE_CHORE == "checkIntegTestResultsOverview") {
                    return ["check"]
                    } else if (RELEASE_CHORE == "addRcDetailsComment") {
                    return ["add"]
                    } else if (RELEASE_CHORE == "buildRC") {
                    return ["both", "opensearch", "opensearch-dashboards"]
                    } else {
                    return ["Unknown chore"]
                    }'''])
        )
        string(
            name: 'RELEASE_VERSION',
            description: 'Release version to be used for the release chore',
            trim: true
        )
        string(
            name: 'GIT_LOG_DATE',
            description: 'Enter data to check commits for release notes in format yyyy-mm-dd, example 2022-07-26.',
            trim: true
        )

    }
    stages {
        stage('Parameters Check') {
            steps {
                script {
                    if (params.RELEASE_VERSION.isEmpty()) {
                        currentBuild.result = 'ABORTED'
                        error('RELEASE_VERSION parameter cannot be empty!')
                    }
                    currentBuild.description = "${params.RELEASE_CHORE}/${params.ACTION}/${params.RELEASE_VERSION}"
                }
            }
        }
        stage('addRcDetailsComment') {
            when {
                expression { params.RELEASE_CHORE == 'addRcDetailsComment' }
            }
            steps {
                script {
                    addRcDetailsComment(
                        version: "${params.RELEASE_VERSION}"
                        )
                }
            }
        }
        stage('checkReleaseOwners') {
            when {
                expression { params.RELEASE_CHORE == 'checkReleaseOwners' }
            }
            steps {
                script {
                    checkRequestAssignReleaseOwners(
                        inputManifest: [
                            "manifests/${params.RELEASE_VERSION}/opensearch-${params.RELEASE_VERSION}.yml",
                            "manifests/${params.RELEASE_VERSION}/opensearch-dashboards-${params.RELEASE_VERSION}.yml"
                            ],
                        action: "${params.ACTION}",
                        )
                }
            }
        }
        stage('checkDocumentationIssues') {
            when {
                expression { params.RELEASE_CHORE == 'checkDocumentation' }
            }
            steps {
                script {
                    checkDocumentationIssues(
                        version: "${params.RELEASE_VERSION}",
                        action: "${params.ACTION}",
                        )
                }
            }
        }
        stage('checkCodeCoverage') {
            when {
                expression { params.RELEASE_CHORE == 'checkCodeCoverage' }
            }
            steps {
                script {
                    checkCodeCoverage(
                        inputManifest: [
                            "manifests/${params.RELEASE_VERSION}/opensearch-${params.RELEASE_VERSION}.yml",
                            "manifests/${params.RELEASE_VERSION}/opensearch-dashboards-${params.RELEASE_VERSION}.yml"
                            ],
                        action: "${params.ACTION}",
                        )
                }
            }
        }
        stage('checkReleaseNotes') {
            when {
                expression { params.RELEASE_CHORE == 'checkReleaseNotes' }
            }
            steps {
                script {
                    switch(params.ACTION) {
                        case 'check':
                            echo "Checking release notes"
                            checkAndNotifyReleaseNotes()
                            break
                        case 'create':
                            if (params.GIT_LOG_DATE.isEmpty()) {
                                currentBuild.result = 'ABORTED'
                                error('GIT_LOG_DATE parameter cannot be empty for checkReleaseNotes')
                            }
                            echo "Creating release notes for all components by triggering release-notes-generate job"
                            build job: 'release-notes-generate', 
                            propagate: false,
                            wait: true,
                            parameters: [
                                string(name: 'INPUT_MANIFEST', value: "${params.RELEASE_VERSION}/opensearch-${params.RELEASE_VERSION}.yml"),
                                string(name: 'GIT_LOG_DATE', value: "${params.GIT_LOG_DATE}")
                            ]

                            build job: 'release-notes-generate', 
                            propagate: false,
                            wait: true,
                            parameters: [
                                string(name: 'INPUT_MANIFEST', value: "${params.RELEASE_VERSION}/opensearch-dashboards-${params.RELEASE_VERSION}.yml"),
                                string(name: 'GIT_LOG_DATE', value: "${params.GIT_LOG_DATE}")
                            ]
                            break
                        case 'compile':
                            echo "Creating consolidated release notes by triggering release-notes-tracker job"
                            build job: 'release-notes-tracker', 
                            propagate: false,
                            wait: true,
                            parameters: [
                                string(name: 'RELEASE_VERSION', value: "${params.RELEASE_VERSION}"),
                                string(name: 'ACTION', value: 'compile'),
                                string(name: 'GIT_LOG_DATE', value: "${params.GIT_LOG_DATE}")
                            ]
                            break
                        case 'notify':
                            echo "Notifying release notes"
                            checkAndNotifyReleaseNotes()
                            break
                        default:
                            currentBuild.result = 'ABORTED'
                            error("Unknown action ${params.ACTION} for checkReleaseNotes")
                    }
                }
            }
        }
        stage('checkReleaseIssues') {
            when {
                expression { params.RELEASE_CHORE == 'checkReleaseIssues' }
            }
            steps {
                script {
                    checkReleaseIssues(
                        version: "${params.RELEASE_VERSION}",
                        inputManifest: [
                            "manifests/${params.RELEASE_VERSION}/opensearch-${params.RELEASE_VERSION}.yml",
                            "manifests/${params.RELEASE_VERSION}/opensearch-dashboards-${params.RELEASE_VERSION}.yml"
                            ],
                        action: "${params.ACTION}",
                        )
                }
            }
        }
        stage('checkDocumentationPullRequests') {
            when {
                expression { params.RELEASE_CHORE == 'checkDocumentationPullRequests' }
            }
            steps {
                script {
                    checkDocumentationPullRequests(
                        version: "${params.RELEASE_VERSION}"
                        )
                }
            }
        }
        stage('checkIntegTestResultsOverview') {
            when {
                expression { params.RELEASE_CHORE == 'checkIntegTestResultsOverview' }
            }
            steps {
                script {
                    checkIntegTestResultsOverview(
                        inputManifest: [
                            "manifests/${params.RELEASE_VERSION}/opensearch-${params.RELEASE_VERSION}.yml",
                            "manifests/${params.RELEASE_VERSION}/opensearch-dashboards-${params.RELEASE_VERSION}.yml"
                            ]
                        )
                }
            }
        }
        stage('buildRC') {
            when {
                expression { params.RELEASE_CHORE == 'buildRC' }
            }
            steps {
                script {
                    buildRC(
                        version: "${params.RELEASE_VERSION}",
                        product: "${params.ACTION}"
                        )
                    // Add RC details comment if both products are built    
                    if (params.ACTION == 'both') {
                        addRcDetailsComment(
                            version: "${params.RELEASE_VERSION}"
                        )
                    }
                }
            }
        }
    }
    post() {
        always {
            script {
                postCleanup()
            }
        }
    }
}

def checkAndNotifyReleaseNotes() {
        if (params.GIT_LOG_DATE.isEmpty()) {
            currentBuild.result = 'ABORTED'
            error('GIT_LOG_DATE parameter cannot be empty for checkReleaseNotes')
        }                    
        sh """
            #!/bin/bash
            set +e
            ./release_notes.sh check manifests/${params.RELEASE_VERSION}/opensearch-${params.RELEASE_VERSION}.yml manifests/${params.RELEASE_VERSION}/opensearch-dashboards-${params.RELEASE_VERSION}.yml --date ${params.GIT_LOG_DATE} --output ${WORKSPACE}/table.md
        """
        checkReleaseNotes(
            version: "${params.RELEASE_VERSION}",
            dataTable: "${WORKSPACE}/table.md",
            action: "${params.ACTION}"
            )
}